# 파일과 스트림(Stream), 기본적인 파일의 입출력  

- 파일은 운영체제에 의해 관리가 되기 때문에 운영체제와 파일의 관계를 이해하는 것부터 시작해야한다.  

## 파일에 저장되어 있는 데이터를 읽으려면  

- 구현한 프로그램과 참조할 데이터가 저장되어 있는 파일 사이에 데이터가 이동할 수 있는 다리를 놓는다. (다리 == 스트림)  
- 파일뿐만 아니라 스트림의 형성도 운영체제의 몫  

## fopen 함수호출을 통한 파일과의 스트림 형성과 FILE 구조체  

- 스트림 형성 시 호출하는 함수  
```c
#include <stdio.h>
FILE * fopen(const char * filename, const char * mode);
```
- 성공 시 해당 파일의 FILE 구조체 변수의 주소 값, 실패 시 NULL 포인터 반환  
- 첫 번째 인자: 스트림을 형성할 파일의 이름  
- 두 번째 인자: 형성할 스트림의 종류에 대한 정보를 문자열 형태로 전달  
- 해당 파일과의 스트림을 형성하고 스트림 정보를 FILE 구조체 변수에 담아 그 변수의 주소 값을 반환한다.    
- FILE 구조체의 포인터는 파일을 가리키기 위한 용도로 사용  
 - `fopen` 함수가 호출되면 FILE 구조체 변수가 생성  
 - 생성된 FILE 구조체 변수에는 파일에 대한 정보가 담김  
 - FILE 구조체의 푕ㄴ터는 사실상 파일을 가리키는 '지시자'의 역할  

## 입력 스트림과 출력 스트림의 생성  
- 스트림: 한 방향으로 흐르는 데이터의 흐름  
- 입력 스트림: 데이터를 파일로 읽어 들이기 위한 것  
- 출력 스트림: 데이터를 파일에 쓰기 위한 것  
```c
FILE * fp = fopen("data.txt", "wt");
```
- 출력 스트림의 형성성  
- 파일 'data.txt'와 스트림을 형성하되 wt 모드로 스트림을 형성하라.  
- wt 모드의 스트림: 텍스트 데이터를 쓰기 위한 출력 스트림  

```c
FILE * fp = fopen("data.txt", "rt");
```
- 입력 스트림의 형성  
- 파일 'data.txt'와 스트림을 형성하되 rt 모드로 스트림을 형성하라.  
- rt 모드의 스트림: 텍스트 데이터를 읽기 위한 입력 스트림  

- `fopen` 함수의 호출을 통해서 파일과의 스트림이 형성되었을 때 **'파일이 개방(오픈)되었다.'**라고 펴한하는 것이 일반적   

## 파일에 데이터를 써보기   

```c
#include <stdio.h>

int main(void)
{
    FILE * fp = fopen("data.txt", "wt");
    if(fp==NULL) {
        puts("파일 오픈 실패!");
        return -1;      // 비정상적인 종료를 의미하기 위해 -1을 반환
    }

    fputc('A', fp);
    fputc('B', fp);
    fputc('C', fp);
    fclose(fp);     // 스트림의 종료
    return 0;
}
``` 
- 스트림이 형성되면 fp가 파일 data.txt를 지칭하는 포인터가 된다.  
- `fputc` 함수가 실행되면 문자가 저장된다.  
- 마지막 `fclose` 함수가 호출되면 데이터는 안정적으로 저장되고 data.txt와 연결되었던 출력 스트림은 소멸된다.  
- 파일 경로는 실행환경 및 설정에 따라 다른데 경로를 다음과 같이 지정해 줄 수도 있다.  
```c
FILE * fp = fopen("C:\\Project\\data.txt", "wt");  
```  

## 스트림의 소멸을 요청하는 fclose 함수  

```c
#include <stdio.h>
int close(FILE * stream);
```
- 성공 시 0, 실패 시 EOF를 반환  
- `fclose` 함수 호출을 통해 개방되었던 파일을 닫아줘야 하는 이유  
 - 운영체제가 할당한 자원의 반환
 - 버퍼링 되었던 데이터의 출력  
 - 실제로 스트림을 형성하는 주체는 운영체제, 운영체제는 스트림의 형성을 위해 시스템의 자원(주로 메모리)를 할당한다.  
 - 자원은 파일을 닫아주지 않으면 할당된 채로 남아있게 되어 그만큼의 자원손실을 초래  
 - 출력버퍼에 문자가 남아있는 상태에서 컴퓨터가 꺼져버리면 파일에 저장이 되지 않기때문에 `fclose`로 파일을 닫아주면 출력버퍼가 비워지게 됨.  

## fflus 함수  
```c
#include
int fflush(FILE * stream);
```
- 함수호출 성공 시 0, 실패 시 EOF 반환  

- 입출력버퍼를 비우는 것 
 - 출력버퍼에 저장된 데이터를 목적지로 전송한다는 의미  
 - 입출력버퍼에 저장된 데이터를 소멸시킨다는 의미  
 - `fflush` 함수는 출력버퍼를 비우는 함수  
 - `fflush` 함수는 입력버퍼를 대상으로 호출 x   

## 파일로부터 데이터 읽기  

- `fgetc` 함수 이용  
```c
int ch = fgetc(fp);
```

# 파일의 개방 모드(Mode)  

스트림의 종류는 다양한데 기본적으로 다음 두 가지 기준을 통해서 스트림을 구분하게 된다.  
- 읽기 위한 스트림? 쓰기 위한 스트림?  
- 텍스트 데이터를 위한 스트림? 바이너리 데이터를 위한 스트림?  

## 읽기 위한 스트림? 쓰기 위한 스트림?  
- 데이터 READ 스트림: 읽기만 가능  
- 데이터 WRITE 스트림: 쓰기만 가능  
- 데이터 APPEND 스트림: 쓰되 덧붙여 쓰기만 가능  
- 데이터 READ/WRITE 스트림: 읽기, 쓰기 모두 가능  

- C언어에서는 위를 바탕으로 6가지로 세분화  
 - r: 읽기 가능 - 파일이 없으면 에러  
 - w: 쓰기 가능 - 생성  
 - a: 파일의 끝에 덧붙여 쓰기 가능 - 생성  
 - r+: 읽기/쓰기 가능 - 에러  
 - w+: 읽기/쓰기 가능 - 생성   
 - a+: 읽기/덧붙여 쓰기 가능 - 생성  
- 모드의 이름이 `fopen` 함수의 두 번째 인자  
 - 모드의 +는 읽기, 쓰기가 모두 가능한 스트림의 형성을 의미  
 - 모드의 a는 쓰기가 가능한 스트림을 형성, 여기서 말하는 쓰기는 덧붙이기   


> 웬만하면 r,w,a 중에서 선택하기  
 +가 들어간 개방 모드는 읽기에서 쓰기, 쓰기에서 읽기로 작업 변경 때마다 메모리 버퍼를 비워줘야 하는 등의 불편함과 더불어 잘못된 사용의 위험성도 뒤따른다.  


## 텍스트 파일과 바이너리 파일  
- 텍스트 파일: 사람이 인식할 수 있는 문자를 담고 있는 파일  
- 바이너리 파일: 컴퓨터가 인식할 수 있는 데이터를 담고 있는 파일  

## 개행  
- 개행은 줄이 바뀌었다는 현상이지 그 자체가 하나의 데이터로 존재하지 않는다.  
- '\n'은 C언어만의 약속이다.  
- 다른 환경에서 개행의 표시  
 - MS-DOS(Windows) - \r\n  
 - Mac - \r  
 - Unix - \n  
- 형태 변환이 필요하다.  

## 텍스트모드와 바이너리 모드  

- 텍스트 모드: 형태의 변환이 자동으로 이뤄진다.  
- 텍스트 모드의 파일 개방을 위해서는 `fopen` 함수의 두 번째 인자로 다음 중 하나를 전달  
 - rt, wt, at, r+t, w+t, a+t  
 - 파일 개방 모드에 텍스트 모드를 의미하는 t가 붙은 상태  
- 바이너리 데이터를 저장하는 파일은 이러한 형변환이 일어나면 안되기 때문에 바이너리 모드로 파일 개방  
 - rb, wb, ab, r+b, w+b, a+b  
 - 바이너리 모드를 의미하는 b가 붙은 형태  
- 개방 모드에 t, b를 모두 붙여주지 않으면 텍스트 모드로 개ㅏㅂㅇ  

> w+t vs. wt+  
 둘은 동일한 의미이다. t는 w와 + 사이, 또는 끝에 올 수 있다.  


