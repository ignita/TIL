# 매크로와 선행처리기 1    

## 선행처리 = 컴파일 이전의 처리  

![선행처리](http://cfile4.uf.tistory.com/image/231D3E40534C8FF032A47F)   

- 컴파일 과정 → 오브젝트 파일 생성(바이너리 데이터로 이뤄진)   
- 선행처리 과정 → 그냥 소스파일  
 - 선행처리기는 삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정(단순 치환)  
 - 예)
 ```c
 #define PI  3.14
 ```
 - PI를 만나면 3.14로 치환하라.  
 - 선행처리 명령문은 `#` 문자로 시작   
 - 컴파일러가 아닌 선행처리기에 의해 처리되는 문장이므로 세미콜론을 붙이지 않는다.  
 ![선행처리결과](http://cfile3.uf.tistory.com/image/27264343534C901429E3F4)  

 >  
  `#include <stdio.h>` 도 #문자로 시작하는 선행처리 명령문이다. "stdio.h 파일의 내용을 이곳에 가져다 놓으세요."라는 의미.   

## 대표적인 선행처리 명령문  

### #define: Object-like macro  

![선행처리명령문구성](http://cfile9.uf.tistory.com/image/23423840534C90702BEFCA)  
- 선행처리 명령문의 구성  
 - 제일 먼저 등장하는 `#define`을 가리켜 '지시자': 선행처리기가 이 부분을 보고 지시하는 바를 파악  
  - `#define` 지시자는 선행처리기에게 "이어서 등장하는 매크로를 마지막에 등장하는 매크로 몸체로 치환하라!"라고 지시한다.  
 - `#define` 뒤에 등장하는 것을 '매크로', 그 뒤에 등장하는 것을 '매크로 몸체(또는 대체 리스트)'   
- 매크로 PI를 매크로 몸체 3.1415로 전부 치환하라.   
- PI와 같은 매크로를 '오브젝트와 유사한 매크로(object-like macro)' 또는 '매크로 상수'라 한다.  

> 오브젝트(object) 유사 매크로  
오브젝트(object)라는 것은 그 자체로 '완전한 의미를 갖는 대상이나 사물'을 의미.   

```c
#include <stdio.h>

#define NAME            "홍길동"
#define AGE             24
#define PRINT_ADDR      puts("주소: 경기도 용인시\n");

int main(void)
{
    printf("이름: %s \n", NAME);
    printf("나이: %d \n", AGE);
    PRINT_ADDR;
    return 0;
}
```
- 매크로의 이름은 대문자로 정의하는 것이 일반적  
- 함수 호출문 이나 대부분의 것을 매크로로 정의할 수 있다.   

### #define: Function-like macro  

- 매크로는 매개변수가 존재하는 형태로도 정의 가능  
- 동작방식이 함수와 유사해 '함수와 유사한 매크로(function-like macro)'라 한다. 줄여서 '매크로 함수'  
- 예
 - `#define SQUARE(X) X*X`   
  - X는 다른 것이어도 된다.(정해지지 않은 임의의 값 또는 문장)  
  - `SQUARE(X)` 라는 패턴 등장 시 `X*X`로 바꾸어라.   
  - 선행처리기는 `SQUARE(X)`와 동일한 패턴을 만나면, 무조건 `X*X`로 치환한다.   
- 선행처리기에 의해서 변환되는 과정 자체를 가리켜 '매크로 확장(macro expansion)'이라 한다.   

```c
#include <stdio.h>
#define SQUARE(X) X*X

int main(void)
{
    int num = 20;


    /* 정상적 결과 출력 */
    printf("Square of num: %d \n", SQUARE(num));
    printf("Square of -5: %d \n", SQUARE(-5));
    printf("Square of 2.5: %g \n", SQUARE(2.5));

    /* 비정상적 결과 출력 */
    printf("Square of 3+2: %d \n", SQUARE(3+2));
    return 0;
}
```
```
Square of num: 400 
Square of -5: 25 
Square of 2.5: 6.25 
Square of 3+2: 11 
```
- 2행에 정의된 매크로에 문제가 있음을 확인할 수 있다.   

### 잘못된 매크로 정의   
```c
SQUARE(3+2)
```
- 3+2의 값인 5가 전달되어야 하는데 연산결과를 가지고 함수를 호출하는 것은 컴파일러이지 선행처리기가 아니다. 하지만 매크로는 선행처리기에 의해 처리가 된다. 그래서 위 문장은 다음과 같이 처리가 된다.  
```c
3+2*3+2
```
- 해결책은 문장을 다음과 같이 구성하면 된다.  
```c
SQUARE((3+2))
```
- 그러나 위 문장은 사용자에게 주의를 요하는 형태라서 안정적이지 못하다.   

### 매크로 몸체에 괄호를 치자.   
- 매크로를 다음과 같이 정의하면 정상적인 값이 출력된다.  
```c
#define SQUARE(X) (X)*(X)
```
- 그러나 다음과 같은 경우에는 나눗셈 먼저 진행되어 원하는 값(30으로 num을 초기화)이 나오지 않는다.  
```c
int num = 120/SQUARE(2);
```   
- 그럼 다음과 같이 매크로 함수를 정의해야 한다.   
```c
#define SQUARE(X) ( (X) * (X) )
```
- **매크로 함수를 정의할 때에는 매크로의 몸체부분을 구성하는 X와 같은 전달 인자 하나하나에 괄호를 해야 함은 물론, 반드시 전체를 괄호로 한번 더 묶어줘야 한다.**   


### 매크로를 두 줄에 걸쳐 정의하려면   

- 매크로를 두 줄 이상에 걸쳐 정의할 때에는 다음과 같이 `\`문자를 활용해 줄이 바뀌었음을 명시  
```c
#define SQUARE(X)    \
        ((X)*(X))
```


### 매크로 정의 시, 먼저 정의된 매크로도 사용 가능  
```c
#include <stdio.h>
#define PI 3.14
#define PRODUCT(X, Y) ((X)*(Y))
#define CIRCLE_AREA(R) (PRODUCT((R), (R))*PI)

int main(void)
{
    double rad = 2.1;
    printf("반지름 %g인 원의 넓이: %g \n", rad, CIRCLE_AREA(rad));
    return 0;
}
```
```
반지름 2.1인 원의 넓이: 13.8474 
```  

### 매크로 함수의 장점   

- 매크로 함수는 일반 함수에 비해 실행속도가 빠르다.  
 - 함수 호출 시 일어나는 일들  
  - 호출된 함수를 위한 스택 메모리의 할당  
  - 실행위치의 이동과 매개변수로의 인자 전달  
  - return 문에 의한 값의 반환  
 - 매크로 함수는 선행처리기에 의해 매크로 함수의 몸체부분이 매크로 함수의 호출 문장을 대신하기 때문에 위의 사항들을 동반하지 않는다.   
- 자료형에 따라서 별도로 함수를 정의하지 않아도 된다.  

### 매크로 함수의 단점   
- 정의하기가 정말로 까다롭다.  
```c
int DiffABS(int a, int b)
{
    if(a>b)
        return a-b;
    else
        return b-a;
}
```
```c
#define DIFF_ABS(X, Y)    ( (X)>(Y) ? (X)-(Y) : (Y)-(X) )
```
- 디버깅하기가 쉽지 않다.   
 - 매크로를 잘못 정의할 경우, 에러 메시지는 선행처리 이전의 소스파일을 기준으로 출력 x, 선행처리 이후의 소스파일을 기준으로 출력  

### 매크로로 정의하는 함수  
- 작은 크기의 함수  
- 호출의 빈도수가 높은 함수   



