<!-- $theme: default -->

# 소프트웨어 개발의 기초 

## 객체지향 기법의 개요 

### 객체지향 기법의 개요 
- 현실의 개체(Entity)를 기계의 부품처럼 하나의 **객체(Object)** 로 만들어, 부품을 조립해 제품을 만들 듯 소프트웨어 개발에도 객체를 조립해서 작성하도록 하는 기법 
	- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택 
	- 소프트웨어의 재사용 및 확장을 용이하게 함.
	- 고품질의 소프트웨어를 빠르게 개발, 유지보수가 쉬움 
	- 복잡한 구조를 단계적・계층적으로 표현, 멀티미디어 데이터 및 병렬처리를 지원 
	- 현실세계를 모형화, 사용자와 개발자가 쉽게 이해 
	- 구성 요소
		- 객체(Object)
		- 클래스(Class)
		- 메시지(Message)

### 객체(Object)
- 객체: 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 소프트웨어 모듈 
	- 데이터
		- 객체가 가지고 있는 정보. 속성이나 상태, 분류 등을 나타냄 
		- 속성(Attribute), 상태, 변수, 상수, 자료구조라고도 함 
	- 함수 
		- 객체가 수행하는 기능 
		- 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘 
		- 객체의 상태를 참조하거나 변경하는 수단
		- 메소드(Method), 서비스(Service), 동작(Operation), 연산이라고도 함 
		- 기존의 구조적 기법에서의 함수, 프로시저에 해당 

- 객체는 상태와 행위를 가짐
- 객체는 다른 객체들과 구별될 수 있는 이름을 가짐. 일정한 기억장소도 가짐.
- 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 수행하게 됨. 

### 클래스(Class)
- 공통된 속성과 연산(행위)를 갖는 객체의 집합 
- 객체의 일반적인 타입(Type)
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀 
- 클래스에 속한 각각의 객체는 인스턴스(Instance)
- 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)
- 동일한 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가짐
	- 그 속성에 대한 정보는 서로 달라 동일 기능을 하는 여러 가지 객체를 나타내게 됨 
- 최상위 클래스: 상위 클래스를 갖지 않는 유일한 클래스 
- 슈퍼 클래스: 특정 클래스의 상위(부모) 클래스
- 서브 클래스: 특정 클래스의 하위(자식) 클래스 

### 메시지(Message) 
- 객체들 간에 상호작용 하는 수단 
- 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항 
- **메시지의 구성 요소**
	- 메시지를 받는 객체의 이름 
	- 객체가 수행할 메소드 이름 
	- 메소드를 수행할 때 필요한 인자(속성값): 옵션. 필요할 때만 사용 
- 메시지를 받은 수신 객체는 요구된 메소드(동작, 연산)을 수행해 결과를 반환 


## 객체지향 기법의 기본 원칙 

### 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶은 것 
- 캡슬화된 객체의 세부 내용은 외부에 은폐(정보 은닉)되어, 변경이 발생하면 오류 파급 효과가 적음 
- 캡슐화된 객체는 재사용 용이
- 객체들 간의 메세지를 주고 받을 땐 각 객체의 세부 내용 필요 x, 인터페이스가 단순해지고, 객체간 결합도 ↓

### 정보 은닉(Information Hiding)
- 약 먹을때 약의 성분을 모르고 복용하는 거랑 같은 의미 
- 다른 객체에게 자신의 정보를 숨겨 자신의 연산만을 통한 접근만 허용 
- 각 객체의 수정이 다른 객체에 주는 영향 최소화 
- 유지보수와 소프트웨어 확장 시 오류 최소화 

### 추상화(Abstraction)
- 불필요한 부분 생략 → 모델화 하는 것(중요한 부분만) 
- 완전한 시스템 구축 전 그 시스템과 유사한 모델을 만들어 여러 요인을 테스트 가능함 
- 최소의 비용으로 실제 상황에 대처, 시스템의 구조 및 구성을 가시적으로 파악 

### 상속성(Inheritance)
- 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스가 물려받는 것 
	- 하위 클래스는 상위 클래스의 모든 속성과 연산을 다시 정의하지 않고도 즉시 자신의 속성으로 사용 가능 
	- 상속받은 속성 외에 새로운 속성과 연산도 첨가해 사용 가능 
	- 객체와 클래스의 재사용. **소프트웨어 재사용** 증대 
	- **다중 상속성(Multiple Inheritance)** : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것 


### 다형성(Polymorphism) 
- 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각 객체(클래스)가 가지고 있는 고유한 특성으로 대답하는 능력 
	- 객체(클래스)들은 동일한 메소드명을 사용해 같은 의미의 응답 
	- 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스들의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것 

## 객체지향 기법의 생명 주기 

### 생명 주기 
- 각 과정에서 사용되는 객체, 클래스, 메소드, 속성 등이 동일한 개념으로 사용됨 
- 개발 전 과정에 걸쳐 동일한 방법론, 표현 기법이 적용되는 장점
- 같은 용어와 개념을 사용해 분석, 설계, 구현 단계 사이에 전환이 쉬워 각 과정이 명확하게 순차적으로 이루어지지는 않음 
- 계획 및 분석 → 설계 → 구현 → 테스트 및 검증 

### 객체지향 분석 
OOA; Object Oriented Analysis 
- 사용자의 요구사항을 분석해 요구된 문제와 관련된 모든 클래스(객체), 이와 관련된 속성과 연산, 그들간의 관계 등을 정의해 모델링하는 작업 
	- 소프트웨어 개발을 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분등으로 나누어 분석
	- 분석가에게 주요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해 문제를 모형화할 수 있도록 하게 해줌 
	- 객체는 클래스로부터 인스턴스화, 이 클래스를 식별하는 것이 객체지향분석의 주요한 목적 
	- 방법론
		- Rumbaugh(럼바우)
		- Booch(부치)
		- Jacobson
		- Coad와 Yourdon
		- Wirfs-Brock 

### 객체지향 설계 
OOD; Object Oriendted Design
- OOA를 사용해서 생성한 여러 가지 분석 모델을 설계 모델로 변환하는 작업 
- 시스템 설계와 객체 설계를 수행
	- 사용자 중심, 대화식 프로그램 개발에 적합
	- 객체지향 설계에서 가장 중요한 것은 시슽메을 구성하는 객체와 속성, 연산을 인식하는 것 
	- 설계 개념
		- 추상화
		- 정보 은닉
		- 기능 독립성
		- **모듈화**
		- 상속성
	- 럼바우 객체지향 설계가 가장 많이 사용됨 
	- 설계 단계 순서 
		- 문제 정의 → 요구 명세화 → 객체 연산자 정의 → 객체 인터페이스 결정 → 객체 구현 

### 객체지향 구현 
- 설계 단계에서 생성된 설계 모델 + 명세서를 근거로 코딩하는 단계 
- 객체 지향 프로그래밍 이용 
- 객체는 순차적, 동시적으로 구현 가능 

OOP; Object Oriented Programming 
- 객체라는 단위 중심으로 프로그램을 개발하는 기법 
	- 현실 세계에 가까운 방식으로 프로그래밍 
	- 이해하기 쉽고 조작하기 쉽다.
	- 유지보수가 쉽고, 재사용 가능한 프로그램을 만들 수 있음
	- 이미 개발된 프로그램을 이용해 빠르게 확장된 프로그램 개발 가능 
	- 객체 기반 언어: Ada, Actor 
	- 클래스 기반 언어: Clu
	- 객체 지향성 언어: Smalltalk, C++, Objective C, java 

### 객체지향 테스트 
- 클래스 테스트: 캡슐호된 객체나 클래스를 검사하는 것
- 통합 테스트: 객체 몇 개를 결합해 하나의 시스템으로 완성시키는 과정에서의 검사 
	- 스레드 기반 테스트: 시스템에 대한 하나의 입력이나 이벤트에 응답하는 데 요구되는 클래스들을 통합. 각각의 스레드가 통합되고 개별적으로 테스트됨 
	- 사용 기반 테스트: 독립 클래스 테스트 후 독립 클래스를 사용하는 다음 계층의 종속 클래스 테스트 
- 확인 테스트: 사용자 요구사항에 대한 만족 여부 검사
- 시스템 테스트: 모든 요소들이 적합하게 통합되고 올바른 기능을 수행하는지 검사 

## 아키텍처 스타일 
기존의 시스템 개발 시 개발자가 아닌 다른 사람이 유지보수하는 경우 설계 방식이 달라 코드 분석시 어렵다. 이를 해결하기 위해 **신뢰 있는 기관에서 검증된 보편적인 설계 방법의 양식들을 사용** → 아키텍처 스타일 
아키텍처 모델(애플리케이션 개발 모델): 아키텍처 스타일에 있는 여러 설계 방식들 

### IEEE 1471
- ANSI / IEEE 1471-2000의 약어 
- 아키텍처가 표현해야 하는 요소와 내용들, 이들 간의 관계를 규정하는 국제 표준 
- 특징
	- 표준화: 아키텍처 관련 용어와 개념들을 통일 
	- 중립성: 모델링 언어와 방법론을 제시하지 않고, 독립적인 메타 모델을 제공 
	- 유연성: 표현을 위한 요소들과 관계의 일반화. 규모에 상관없이 시스템 구축 적용 가능 
	- 의사소통: 이해당사자 간의 의사소통 지원, 다양한 관점에서 표현 

- 구성요소 
	- Architectural Description(AD): 시스템 구축 시 아키텍처가 기록되는 방법 
	- Stakeholder: 개발에 관련된 모든 이해당사자를 의미(예: 고객, 개발자, 관리자, 마케터 등) 
	- Concerns: 시스템의 성능, 유지보수, 보안, 분배 등과 같은 Stakeholder들의 의견, 목표
	- View: Stakeholder들이 가지는 관점. 시스템을 표현하거나 묘사하는 방법
	- Viewpoint: View를 구성하기 위한 규칙을 정의하는 패턴, AD는 하나 이상의 Viewpoint를 선택해 사용 

### 저장소 구조 
- 중앙자료구조 + 독립된 컴포넌트 
- 큰 데이터의 이동 및 공유에 적합 
- 컴포넌트 간 통신 x 
- 장점
	- 대량의 데이터를 저장 효과적 
	- 컴포넌트의 추가・삭제가 편리
	- 중앙 집중화를 통해 데이터 관리가 용이
	- 보안적인 측면 뛰어남

- 단점
	- 저장소에 오류 발생시 시스템 전체에 문제 발생
	- 데이터 분산이 어려움

### MVC 구조(Model/View/Controller Architecture)
- UI와 비즈니스 로직들을 서로 분리해 개발하는 방법
- 구성요소
	- 모델
		- 애플리케이션의 핵심 기능 포함
		- 상태 변화 시 컨트롤러와 뷰에 전달

	- 뷰
		- 정보 표시를 관리
		- 결과물 생성을 위해 모델로부터 정보를 수신

	- 컨트롤러
		- 사용자로부터 입력을 받아 모델과 뷰에 명령 전달 
		- 모델에 명령을 전달해 상태를 변경, 뷰에 명령을 보내 표시 방법을 변경 

- 장점
	- 동일한 모델에 대해 다양한 뷰 제공
	- 효율적인 모듈화 가능
	- 모델과 뷰의 구분으로 UI에 대한 요구사항 적용 용이

- 단점
	- 간단한 애플리케이션에 적용하기 복잡
	- 모델이 자주 변경되는 경우 업데이트 요청이 많아 뷰 갱신이 따라가지 못함 

### 클라이언트/서버 구조
- 하나의 서버에 다수의 클라이언트 접속(일대다 관계)
- 서버는 하나의 중앙 서버 또는 분산된 여러 서버가 존재 
- 구성
	- 클라이언트: 사용자로부터 입력을 받아 서버에 요청을 전달
	- 서버: 수신된 요청을 수행. 데이터의 일관성 유지

- 특징
	- 새로운 서버의 추가 및 업그레이드 용이
	- 데이터가 서버에 집중되 데이터 관리 용이. 보안적 측면 뛰어남
	- 서버에 네트워크 트래픽과 데이터 집중이 되어 처리 비용 급증할 수 있음 

### 계층 구조 
- 계층적으로 조직화가 가능한 애플리케이션에 적합 
- 각 계층이 특정 측면만을 전문적으로 다루어 응집력있는 설계 가능 
- 예) OSI 7계층 
	- 상위 계층은 하위 계층의 서비스 제공자 
	- 하위 계층은 상위 계층의 클라이언트의 입장에 섬
	- 복잡한 문제를 점진적, 순차적으로 분할해 구현 가능
	- 인접 계층 사이에서만 요청과 응답이 이루어짐 
	- 변경 사항 적용시에도 인접 계층만 영향을 미쳐 원할한 변경 가능 
	- 특정 계층만을 교체해 시스템을 개선하는 것이 가능하나 동작이 변경될 경우 단계별 재작업이 필요 
	- 구축시 레이어의 적절한 개수나 규모를 결정하는 것에 어려움이 있음 

### 파이프 필터 구조 
- 데이터의 흐름을 점진적으로 처리하는 시스템을 위한 아키텍처
- 프로세싱을 위한 시스템이 각 필터에 캡슐화되어 있음 
- 데이터는 인접 필터 사이 파이프를 통해 전달
- 각 필터들은 상호 독립적.
- 자신의 필터 앞이나 뒤에 있는 필터에 대한 정보 알 수 없음 
- 모든 데이터 처리 순서는 파이프의 구조와 각각의 필터를 통해 조정 가능한 이벤트에 의해 통제됨 
- 장점
	- 설계자는 몇 개의 필터들을 간단히 조합해 시스템의 입・출력 행위를 이해 
	- 새로운 필터를 기존의 구조에 추가/통합 가능
	- 각 필터의 독립적인 구조로 인해 다양한 시스템에 적용 가능(재사용성)
	- 각 필터들의 독립적 수행이 가능해 동시 수행으로 효율성 증진
	- 응답성(throughput)이나 데드락(deadlock)과 같은 특수한 분석들을 지원 
- 단점
	- 상태 정보를 공유하는데 유연 x
	- 각 필터 간 공통된 특성이 적어 각 필터가 전송받는 데이터를 다시 파싱해야하는 경우 발생할 수 있다. 