# 파일과 디렉토리 조작   

- `cp` - 파일 및 디렉토리 복사하기  
- `mv` - 파일 및 디렉토리 이동 그리고 이름 변경하기   
- `mkdir` - 디렉토리 새로 만들기  
- `rm` - 파일 및 디렉토리 삭제하기    
- `ln` - 하드 링크 또는 심볼릭 링크 만들기  

- 위와 같은 명령어들은 GUI 환경의 파일 관리자를 통해 손쉽게 작업할 수 있다. 하지만 커맨드라인 프로그램을 사용하는 이유는??  
 - 커맨드라인의 강력함과 유용성  
 - 예) 어떤 디렉토리에 저장된 모든 HTML 파일을 다른 디렉토리로 복사하려면? 또한 새 파일이나 최신 버전의 파일만 복사하고 싶다면?  
```shell
cp -u *.html destination  
```  


## 와일드카드  
- 쉘은 굉장히 많은 파일명을 사용하기 때문에 간단하게 파일명의 그룹을 지정할 수 있도록 특수한 문자들을 지원  
 - 이러한 특수 문자들을 **와일드카드**라고 한다.(**글로빙**이라고도 함)  
 - 와일드카드를 이용해 문자 패턴에 따라 파일명을 선택 가능  

| 와일드카드 | 매칭 문자 |
| --- | --- |
| `*` | 모든 문자 |
| `?` | 모든 하나의 문자 |
| `[characters]` | _characters_ 문자셋에 포함된 문자 |
| `[!characters]` | _characters_ 문자셋에 포함되지 않은 문자 |
| `[[:class]]` | 지정된 문자 클래스에 포함된 문자 |  

- 가장 많이 사용되는 문자 클래스  

| 문자 클래스 | 매칭 문자 |
| --- | --- |
| `[:alnum:]` | 모든 알파벳과 숫자 문자 |
| `[:alpha:]` | 모든 알파벳 문자 |
| `[:digit:]` | 모든 숫자 |
| `[:lower:]` | 모든 소문자 |
| `[:upper:]` | 모든 대문자 |   

- 활용 예제: 아주 복잡한 선택 조건을 파일명에 사용하기   

| 패턴 | 매칭 문자 |
| --- | --- |
| `*` | 모든 파일 |
| `g*` | _g_로 시작하는 모든 파일 |
| `b*.txt` | _b_로 시작하되 _.txt_ 형식 파일 |
| `Data???` | _Data_로 시작하면서 뒤에 정확히 세 개의 문자만 있는 파일 |
| `[abc]*` | _ a, b, c_로 시작하는 모든 파일 |  
| `BACKUP.[0-9][0-9][0-9]` | _BACKUP_으로 시작하면서 뒤에 정확히 세 개의 숫자로 된 파일 |  
| `[[:upper:]]*` | 대문자로 시작하는 모든 파일 |  
| `[![:digit:]]*` | 숫자로 시작하지 않는 모든 파일 |  
| `*[[:lower:]123]` | 파일명이 소문자로 끝나거나 _1, 2, 3_으로 끝나는 파일 |   

## mkdir - 디렉토리 생성  

```shell
mkdir directory...
```  

```shell
mkdir dir1 dir2 dir3 
```
- 뒤에 인자가 반복될 수 있다. 위는 세 개의 디렉토리를 생성  

## cp - 파일 및 디렉토리 복사  

- item 1을 item2라는 파일 또는 디렉토리로 복사  
```shell
cp item1 item2
```
- 다수의 파일이나 디렉토리를 다른 디렉토리로 복사  
```shell
cp item... directory  
```

- cp 옵션  

| 옵션 | long | 설명 |
| --- | --- | --- | 
| a | --archive | 파일 및 디렉토리뿐 아니라 소유자 및 권한 정보와 같은 속성까지 모두 복사 |
| -i | --interactive | 기존 파일을 덮어쓰기 전에 확인 메시지를 출력. |
| -r | --recursive | 디렉토리와 그 안의 내용까지 복사할 때 사용. 이 옵션(또는 -a 옵션)은 디렉토리를 복사할 때 필요 |
| -u | --update | 어떤 디렉토리에 있는 파일을 다른 디렉토리로 복사할 때, 그 디렉토리에는 없거나 최신 버전인 파일만을 복사 |
| -v | --verbose | 복사가 완료되었다는 메시지를 보여줌 |  

- cp 사용 예제  

| 옵션 | 결과 |
| --- | --- |
| `cp file1 file2` | _file1_을 _file2_로 복사하기. **_file2_라는 파일이 이미 있으면 _file1_의 내용을 그대로 덮어씀.** _file2_가 없으면 새로 생성 |
| `cp -i file1 file2` | 위와 같지만 덮어쓰기 여부에 대한 확인 메시지 출력  |
| `cp file1 file2 dir1` | _file1_과 _file2_를 _dir1_ 디렉토리에 복사. 단, _dir1_ 디렉토리는 미리 존재해야 함 |
| `cp dir1/* dir2` | _dir1_ 디렉토리의 모든 파일을 _dir2_ 디렉토리로 복사. 단, _dir2_는 미리 존재해야 함 |
| `cp -r dir1 dir2` | _dir1_ 디렉토리와 그 안에 있는 모든 내용을 _dir2_로 복사. _dir2_가 없으면 새로 생성된다. |  


## mv - 파일 이동과 이름 변경  

- mv 명령어는 어떻게 사용하느냐에 따라 파일을 이동할 수도 있고 파일명을 수정할 수도 있다.  
- item1 파일 또는 디렉토리를 item2로 이동하거나 이름 변경  
```shell
mv item1 item2  
```
- 하나 이상의 파일이나 디렉토리를 다른 디렉토리로 이동  
```shell
mv item... directory
```   

- mv 옵션  

| 옵션 | long | 설명 |
| --- | --- | --- |
| -i | --interactive | 기존의 파일을 덮어쓰기 전에 확인 메시지를 보여줌. **이 옵션 없이 mv 명령어를 사용하면 확인 과정이 없다.** |
| -u | --update | 파일을 다른 디렉토리로 이동하려고 할 때, 그 딝토리에는 없거나 또는 최신 버전인 파일만을 이동 |
| -v | --verbose | 이동이 완료되었다는 메시지를 출력 |  

- mv 사용 예제  

| 사용 예제 | 결과 |
| --- | --- |
| `mv file1 file2` | _file1_을 _fil2_로 이동. file2가 없으면 새로 생성. file1은 사라짐 |
| `mv -i file1 file2` | 사용자에게 덮어쓰기 여부를 확인 |
| `mv file1 file2 dir1` | _file1_과 _file2_를 _dir1_로 이동. _dir1_은 미리 생성되 있어야 한다. |  
| `mv dir1 dir2` | _dir1_과 그 내용까지 모두 _dir2_로 이동. _dir2_가 없었다면 새로 생성. _dir1_은 삭제 |


## rm - 파일 및 디렉토리 삭제  

- rm 명령어는 파일 및 디렉토리를 하나 이상 입력 가능  
```shell
rm item...
```

> **rm 사용시 주의점**  
리눅스같은 유닉스형 운영체제는 삭제를 취소하는 명령어가 없다. 리눅스는 사용자가 똑똑해서 현재 삭제하고 있음을 충분히 인지하고 있다고 가정하기 때문  
**rm과 함께 와일드카드를 사용할 때마다 `ls`로 와일드카드를 먼저 테스트하고 사용하는 것이 안전하다.**  

- rm 옵션  

| 옵션 | long | 설명 |
| --- | --- | --- |
| -i | --interactive | 기존의 파일을 삭제하기 전에 확인 메시지를 보여줌 |
| -r | --recursive | 재귀적으로 디렉토리 삭제. 삭제된 디렉토리에 하위 디렉토리들이 있다해도 삭제하는 것. 완전히 삭제 시 사용 |
| -f | --force | 존재하지 않는 파일은 확인 메시지 없이 무시하라는 옵션. --interactive 옵션을 완전히 무시 |
| -v | --verbose | 삭제가 완료되었다는 메시지 출력 |   

- rm 사용 예제  

| 사용 예제 | 결과 |
| --- | --- |
| `rm file1` | _file1_을 완전히 삭제 |
| `rm -i file1` | _file1_을 삭제하기 전에 확인 메시지를 보여준다. |
| `rm -r file1 dir1` | _file1_과 _dir1_디렉토리 및 하위 내용까지 모두 삭제 |  
| `rm -rf file1 dir1` | _file1_과 _dir1_ 모두 삭제하되 존재하지 않더라도 rm 명령어가 실행된다. |   

## ln -링크 생성  

- 하드 링크 생성  
```shell
ln file link
```  
- item 파일 또는 디렉토리에 심볼릭 링크 생성  
```shell
ln -s item link
```    

### 하드 링크  

- 기본적으로 하나의 파일에는 하나의 하드 링크가 있다. 그것이 바로 파일에 이름을 만들어주는 것.  
- 하드 링크의 약점  
 - 파일시스템 외부에 있는 파일은 참조 x, 하드 링크는 같은 디스크 파티션에 있는 파일이 아니면 참조 x.  
 - 디렉토리를 참조할 수 없다.  
- 하드 링크가 삭제될 때, 링크도 함께 사라지지만 파일 내용은 그 파일의 모든 링크가 삭제될 때까지 계속 남아 있는다.  

### 심볼릭 링크  

- 참조될 파일이나 디렉토리를 가리키는 텍스트 포인터가 포함도니 특수한 파일을 생성  
- 윈도우즈의 바로 가기와 매우 흡사한 방식  
- 심볼릭 링크를 편집하게 되면 심볼릭 링크가 참조하고 있는 파일도 똑같은 변경이 이루어진다.  
- 심볼릭 링크를 삭제하면 그 링크만 삭제되고 파일은 남아있다.  
- 심볼릭 링크를 삭제하기 전에 원본 파일을 지웠다면 링크가 아무것도 가리키지 않게되어 링크가 **깨졌다**고 표현한다.  
 - 많은 쉘에서 ls 명령어로 인해 빨간색이나 다른 색상으로 깨진 링크가 확인 가능하다.   


