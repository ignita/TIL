# 퍼미션  

- 유닉스 계열 운영체제와 MS-DOS 계열 운영체제들과 여러모로 다르다.  
 - MS-DOS 계열은 **멀티태스킹** 시스템도 아니고 **멀티유저** 시스템도 아님.→ 한 명 이상이 동시에 컴퓨터를 사용하는 것  
- 네트워크나 인터넷에 연결된 컴퓨터라면, 원격 사용자가 ssh(secure shell)을 통해 로그인해서 컴퓨터 조작이 가능  
- 수년 전, 컴퓨터가 "개인용"이 되기 전에는 매우 크고 값이 비싸고, 중앙집권적이었기 때문에 중앙 컴퓨터에 각각 연결된 작은 단말기들로 컴퓨터 시스템이 구성되어 있었다. 그 중앙 컴퓨터는 동시에 많은 사용자를 지원했다.  
 - 이를 위해, 다른 사용자로부터 각 사용자를 보호하기 위한 방법이 필요  
  - 한 사용자의 동작으로 인해 컴퓨터가 고장나지 말아야 할 것.  
- 명령어  
 - `id` - 사용자의 ID 정보를 표시  
 - `chmod` - 파일 모드를 변경  
 - `umask` - 기본 파일 퍼미션을 설정  
 - `su` - 다른 사용자로 쉘을 실행  
 - `sudo` - 다른 사용자로 명령어를 실행  
 - `chown` - 파일 소유자 변경  
 - `chgrp` - 파일 그룹 소유자 변경  
 - `passwd` - 사용자 비밀번호 변경  

## 소유자, 그룹 멤버, 기타 사용자  

- etc/shadow 와 같은 파일을 확인하려는 경우에 다음과 같이 문제가 발생할 수 있다.  
```
[me@linuxbox ~]$ file /etc/shadow  
/etc/shadow: regular file, no read permission
[me@linuxbox ~]$ less /etc/shadow  
/etc/shadow: Permission denied
```
- 위 오류의 원인은 해당 파일을 읽을 권한이 없는 일반 사용자이기 때문  
- 유닉스의 보안 모델에서 사용자는 파일과 디렉토리를 **소유**할 수 있다.  
- 사용자가 파일 또는 디렉토리를 소유할 때, 그 사용자는 소유물의 접근을 제어한다.  
- 사용자는 한 명 이상으로 구성된 **그룹**에 속할 수 있다.  
- 같은 그룹 사용자들은 그 소유자에 의해 파일과 디렉토리에 접근 권한을 얻는다.  
- 그룹 접근 허용 외에도 소유자는 모든 사용자(유닉스 용어로는 world)에게 접근 권한 일부를 줄 수 있다.  

- 자신의 사용자 ID 정보 확인은 `id` 명령어 사용  
```
[me@linuxbox ~]$ id
uid=500(me) gid=500(me) groups=500(me)
```
- 사용자 계정 생성 시, 사용자들은 **사용자 ID(user ID)** 또는 uid라 불리는 번호를 할당 받음.  
- 그 후 사용자 이름을 할당  
- 그 사용자는 **주 그룹 ID(gid)**를 할당 받고, 추가로 다른 그룹에도 속할 수 있음..  
- uid와 gid는 페도라는 일반 사용자 계정에 500번 부터, 우분투는 1000번부터 OS X는 501번부터 할당하는 것 같다.  
- 사용자 계정은 /etc/passwd 파일에 정의, 그룹은 /etc/group 파일에 정의  
- 사용자 계정과 그룹 생성 시, 위 파일들은 사용자 비밀번호에 관한 정보를 가진 /etc/passwd 에 덧붙여 수정됨.   
- 각각의 계정은 /etc/passwd 파일에 사용자 이름, uid, gid, 실제 사용자 이름, 홈 디렉토리와 로그인 쉘 정보가 저장  
- 일반 사용자 계정 뿐 아니라 슈퍼유저(uid 0)와 다른 시스템 사용자 계정도 존재  

## 읽기, 쓰기, 실행  

- 파일과 디렉토리의 접근권 - 읽기 권한, 쓰기 권한, 실행 권한  
```
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-r--r--  1 ox  staff  0  6 23 14:24 ls-output.txt
```  
- 첫 10개의 문자는 **파일 속성**  
- 첫 문자는 파일의 종류  

 | **속성** | **파일 종류** |
 | --- | --- |
 | - | 일반 파일 |
 | d | 디렉토리 |
 | l | 심볼릭 링크. 항상 rwxrwxrwx 이고, 그것은 더미 값. 실제는 심볼릭 링크가 가리키는 파일의 속성 |
 | c | 문자 특수 파일. 터미널이나 모뎀같이 바이트의 열로 데이터를 처리하는 디바이스를 나타냄 |
 | b | 블록 특수 파일. 하드 드라이브나 CD-ROM 드라이브 같이 블록 단위의 데이터를 처리하는 디바이스를 나타냄 |  

- 파일 속성의 나머지 9개의 문자는 **파일 모드(file mode)**  
 - 파일 소유자, 파일 소유 그룹, 기타 사용자에 대한 읽기, 쓰기, 실행 권한을 나타냄(3개씩 나눠서)  

- 퍼미션 속성 

 | **속성** | **파일** | **디렉토리** |
 | --- | --- | --- |
 | r | 파일 열기와 읽기 허용 | 실행 속성이 설정되어 있으면 디렉토리의 내용물을 나열할 수 있게끔 허용 |
 | w | 파일 쓰기, 잘라내기 허용. 이름 변경이나 삭제 x | '' 디렉토리 내의 파일들을 생성, 삭제, 이름 변경 가능 |
 | x | 파일이 프로그램으로 처리되고 실행되도록 허용. 스크립트 언어에서 작성된 프로그램 파일들은 읽기 기능으로 설정되어 있어야만 실행 가능 | 디렉토리에 들어올 수 있도록 허용(cd directory와 같이) |  

- 퍼미션 속성 예제  
 - -rwx------ - 파일 소유자에 의해 읽기, 쓰기, 실행 가능한 일반 파일. 다른 사용자는 접근 불가  
 - -rw------- - 파일 소유자에 의해 읽기, 쓰기 가능한 일반 파일. 다른 사용자 접근 불가  
 - -rw-r--r-- - 파일 소유자에 의해 읽기, 쓰기 가능한 일반 파일. 파일 소유 그룹의 멤버와 기타 사용자 읽기 가능  
 - -rwxr-xr-x - 파일 소유자에 의해 읽기, 쓰기, 실행 가능한 일반 파일. 그룹 멤버와 기타 사용자도 읽고 실행 가능  
 - lrwxrwxrwx - 심볼릭 링크. 모든 심볼릭 링크는 가짜(dummy) 퍼미션을 가지고 있음. 실제 퍼미션은 심볼릭 링크가 가리키는 실제 파일을 가지고 있음  
 - drwxrwx--- - 디렉토리. 소유자와 소유그룹 멤버는 디렉토리 안으로 들어갈 수 잇고, 그 안의 파일들을 생성, 삭제 및 이름 변경이 가능  
 - drwxr-x--- - 디렉토리. 소유자는 디렉토리 안으로 들어갈 수 있고, 디렉토리 내의 파일들을 생성, 삭제, 이름 변경 가능. 소유 그룹 멤버는 들어갈 수는 있지만 파일들을 생성, 삭제 및 이름변경이 불가능  

## chmod - 파일 모드 변경  
- `chmod` 명령어 사용  
- 모드의 변경은 오직 파일 소유자나 슈퍼유저만 이가능  
- `chmod` 변경을 표현하는 두 가지 방법  
 - 8진수의 숫자로 표현  
 - 문자로 표현  

### 8진법 표현  

| **8진법** | 2진법 | 파일 모드 |  
| :---: | :---: | :---: | 
| 0 | 000 | --- | 
| 1 | 001 | --x |
| 2 | 010 | -w- |
| 3 | 011 | -wx |  
| 4 | 100 | r-- |  
| 5 | 101 | r-x |  
| 6 | 110 | rw- |
| 7 | 111 | rwx |  

- 3자리 8진수로 소유자, 그룹 소유자, 기타 사용자를 위한 파일 모드 설정이 가능  
```
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-r--r--  1 me  me  0  6 26 09:47 foo.txt
[me@linuxbox ~]$ chmod 600 foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-------  1 me  me  0  6 26 09:47 foo.txt
```
- 인자 600을 전달해 파일 소유자는 읽고 쓸 수 있는 반면, 나머지 사용자들의 모든 권한 제거  
- 7(rwx), 6(rw-), 5(r-x), 4(r--), 0(---)  

### 기호 표현  

- `chmod`는 또한 파일 모드를 지정하기 위해 문자 표기법을 지원  
- 변경할 사용자, 수행할 명령, 설명할 퍼미션, 세 부분으로 나뉨  

 | **기호** | **의미** |  
 | --- | --- |
 | u | user의 약자. 파일이나 디렉토리 소유자를 의미 |  
 | g | 그룹 소유자 | 
 | o | others의 약자. 기타 사용자를 의미 | 
 | a | all의 약자. u, g, o의 조합 |  

- 아무런 문자를 사용하지 않으면 자연스럽게 all로 추정하고, 그 명령은 퍼미션이 추가된 a+가 될 것이다.  
- a -는 퍼미션이 없어진다는 것, a =는 단지 지정된 퍼미션들만 적용되고 나머지는 제거될 것을 나타냄  
- chmod 기호 표기법 예제  

 | **표기법** | **의미** |  
 | --- | --- |  
 | u+x | 소유자에게만 실행 권한을 추가 | 
 | u-x | 소유자의 실행 권한을 제거 | 
 | +x | 모든 사용자(소유자, 그룹, 기타 사용자)에게 실행 권한을 추가(a+x와 동일) | 
 | o-rw | 소유자와 그룹 소유자가 아닌 사용자의 읽기, 쓰기 권한을 제거 | 
 | go=rw | 그룹 소유자와 기타 사용자가 읽기, 쓰기 권한을 갖도록, 실행권한이 있었다면 제거 |  
 | u+x, go=rw | 소유자에게 실행 권한을 추가 그룹, 기타 사용자에게 읽기, 쓰기 권한. 복수 지정은 콤마로 구분 |  

- 기호 표기법은 다른 속성을 건드리지 않고 하나의 속성만을 설정할 수 있다는 이점을 제공  
- --recursive 옵션 사용에 주의: 파일과 디렉토리 모두에게 해당 파일 모드를 적용하는데, 그럴 경우는 드문 일  

## GUI로 파일 모드 설정  
- 노틸러스(Gnome의 Nautilus)와 퀀커러(KDE의 Konqueror) 둘다 파일 또는 디렉토리에서 오른쪽 클릭하면 속성 대화상자가 나타남  
- 여기서 소유자, 그룹, 기타 사용자에 관한 설정이 보임  
- KDE에서 고급 퍼미션 설정 버튼을 클릭 시 각각 따로 모드 속성을 설정할 수 있는 또 다른 대화상자가 열림.  

## umask - 기본 권한 설정  
- `umask`는 파일이 생성될 때 주어진 기본 퍼미션을 제어  
- 파일 모드 속성에서 제거할 비트 **마스크**를 표현하기 위해 8진 표기법 사용  

```
[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ umask
0022
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-r--r--  1 me  me  0  6 26 10:02 foo.txt
```  
- 깔끔하게 시작하기 위해 foo.txt를 제거하고 현재 마스크 값을 보기 위해 umask 명령어를 아무런 인자 없이 실행  
- 현재 마스크 값을 8진 표현인 0022로 반환  
- 끝으로 파일 foo.txt을 새로 생성하고 그것의 퍼미션을 확인  
- 소유자는 읽기와 쓰기 권한을 가지고 있음. 하지만 그룹과 나머지 모든 사용자들은 오직 읽기 권한만 가진다.  
- 마스크를 0000(사실상 끔)로 설정하면, 그 파일은 그룹과 기타 사용자로도 쓰기 가능  
```
[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ umask 0000
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-rw-  1 me  me  0  6 26 10:20 foo.txt
```  

- 마스크를 2진수로 확장하고 속성을 비교하기  

 | 원래 파일 모드 | --- | rw- | rw- | rw- |
 | --- | --- | --- | --- | --- | --- |
 | 마스크 | 000 | 000 | 000 | 010 |
 | 결과 | --- | rw- | rw- | r-- |

 - 마스크에 1이 나타나는 곳을 보면 속성이 제거된다. 마스크가 하는 일이 바로 이것.  
 - 배포판에서 제공하는 기본값은 적당하기에 마스크를 거의 변경할 필요가 없다.  
 - 고도의 보안이 필요한 상황인 경우에는 조절하기를 원할 것이다.  

## 사용자 ID 변경  

- 로그아웃 후 다른 사용자로 로그인  
- su 명령어 사용  
- sudo 명령어 사용  

- su 명령어 사용 시, 다른 사용자의 ID를 상정, 그 ID의 새로운 쉘 세션을 시작하거나 그 사용자로서 명령어를 내보냄  
- sudo 명령어는 관리자가 /etc/sudoers 설정 파일을 설정하게 해주고 다른 사용자의 권한을 가지고 특정 명령어를 실행할 수 있게함  

### su - 다른 사용자 ID와 그룹 ID로 쉘 실행  

- 다른 사용자로 쉘을 시작하기 위해 사용  
```
su [-[l]] [user]
```
- -l 옵션을 사용하면 반환된 쉘 세션은 이 명령에 지정된 사용자를 위한 로그인 쉘이 된다.  
 - 해당 사용자 환경이 로드, 작업 디렉토리가 그 사용자의 홈 디렉토리로 변경됨  
- 사용자를 지정하지 않으면 슈퍼유저로 가정
- -l은 -로 줄여 쓸 수 있고, 대부분 - 를 사용  
- 슈퍼유저로 쉘을 시작하기  
 ```
 [me@linuxbox ~]$ su -  
 Password:
 [root@linuxbox ~]#  
 ```
 - 성공적으로 패스워드를 입력하면 슈퍼유저 특권을 가진 새로운 쉘 프롬프트($가 아닌 #로 시작하는)가 나타난다.  
 - 현재 작업 디렉토리는 슈퍼유저의 홈 디렉토리인(/root)가 된다.    

```
[root@linuxbox ~]# exit
[me@linuxbox ~]$   
```
- exit를 입력해 이전 쉘로 돌아간다.  

- 다음과 같이 su 명령을 사용하면 새로운 명령으로 시작하지 않고 단일 명령어 수행이 가능 
```
su -c command
```
- 위 형태를 사용하면 단일 명령 행이 실행을 위한 새로운 쉘에 전달  
- 기존 쉘이 아닌 새로운 쉘에 확장이 발생하기를 원치 않기 때문에 명령어를 인용부호로 감싸는 것은 중요  
```
[me@linuxbox ~]$ su -c 'ls -l /root/*'
Password:
-rw------- 1 root root ......

/root/Mail:
total 0 
[me@linuxbox ~]$
```

> Mac OS X에서 su 명령어 사용  
http://planmaster.tistory.com/438  

### sudo - 다른 사용자로 명령어 실행  
- su와 비슷하지만 관리자는 매우 통제된 방법하에 일반 사용자가 다른 사용자(대게 슈퍼유저)로 명령을 실행할 수 있게끔 설정할 수 있다.  
- 하나 이상의 지정도니 명령어로 제한  
- sudo는 슈퍼유저의 비밀번호 요구 x  
- sudo 사용을 입증하기 위해 사용자는 단지 자신의 비밀번호를 입력  
- 예를 들어, sudo가 슈퍼유저 특권이 필요한 가상의 백업 프로그램인 backup_script 실행을 허용하게 설정해놨다고 치면,  
```
[me#linuxbox ~]$ sudo backup_script
Password:
System Backup Starting...
```
- sudo는 새로운 쉘을 시작하지 않고, 다른 사용자의 환경도 로드하지 않는다.  
- 명령어들은 sudo를 사용하지 않을 때와 별반 다르지 않게 인용 부호 없이 사용할 수 있다.  
- sudo로 허용된 특권을 확인하기 위해서는 -l 옵션을 사용  


> **우분투와 SUDO**  
윈도우즈의 세계에서는 소프트웨어 설치와 업데이트, 시스템 설정 파이 편집, 장치 접근과 같은 작업들은 종종 관리자 권한이 주어진 사용자에 의해 진행된다. 대부분의 경우에는 적절하지만 바이러스와 같은 멀웨어의 실행 조차도 허용하게 된다.   
유닉스의 세계에서는 항상 일반 사용자와 관리자 사이에 큰 구분을 둔다. 유닉스 멀티유저 시스템의 유산이다. 필요한 경우에만 슈퍼유저 특권을 허용한다. 이를 위해 su와 sudo 명령어가 흔히 사용된다.  
몇 년 전만해도, 리눅스 배포판의 대부분은 su 명령에만 의지를 해서 사용자들이 불필요하게 루트로 명령을 수행하는 유혹에 빠져들었고, 리눅스 시스템의 보안을 윈도우즈 수준으로 약화시켰다.  
우분투가 처음 선보였을 때, 우분투의 창시자는 기존과 다른 방침을 취했다. 기본적으로 우분투는 루트 계정 로그인을 비활성화했고(계정 비밀번호 설정이 불가능하게) 대신에 sudo 명령어로 슈퍼유저 특권을 허용했다.  

## chown - 파일 소유자와 그룹 변경  

- 파일 또는 디렉토리의 소유자와 그룹 소유자를 변경하는 데 사용  
- 슈퍼유저의 권한이 필요하다.  
```
chown [owner][:[group]] file ...
```

- 예제  

 | 인자 | 결과 |
 | --- | --- |
 | bob | 파일의 소유권을 현 소유자에서 bob으로 변경 | 
 | bob:users | 파일의 소유권을 현 소유자에서 bob으로, 파일 그룹 소유자를 users 그룹으로 변경 | 
 | :admins | 파일 그룹 소유자를 admins 그룹으로 변경 |  
 | bob: | 파일 소유자가 현 소유자에서 bob으로, 그룹 소유자는 bob의 로그인 그룹으로 변경 |  


### chgrp - 그룹 소유권 변경  
- 더 많은 제한이 있다는 것을 제외하고는 chown과 동일한 방식으로 동작  

## 사용자 비밀번호 벼 ㄴ경  

```
[me@linuxbox ~]$ passwd
(current) UNIX password:
New UNIX password:
```
- passwd 명령어는 "강력한" 비밀번호의 사용을 강요 
- 만약 슈퍼유저의 권한을 갖고 있다면 passwd 명령의 첫 번째 인자에 사용자 이름을 지정해 그 사용자의 비밀번호 설정이 가능  
