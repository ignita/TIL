# 프로세스  

- 현대의 운영체제들 - 한 프로그램에서 다른 프로그램으로 빠르게 이동함으로써 하나 이상의 작업이 동시에 실행되는 듯한 환상을 심어주는 **멀티태스킹** 방식  
- 리눅스 커널은 프로세스를 통해 멀티태스킹을 관리  
- **프로세스**란 리눅스가 CPU를 사용하기 위해 차례를 기다리는 각 프로그램들을 구조화한 것.  

- 명령어   
 - `ps` - 현재 프로세스의 상태를 알려준다.  
 - `top` - 프로세스를 표시한다.  
 - `jobs` - 실행 작업(jobs)를 나열한다.  
 - `bg` - 프로세스를 백그라운드(background) 상태로 전환한다.  
 - `fg` - 프로세스를 포그라운드(foreground) 상태로 전환한다.  
 - `kill` - 프로세스에 시그널을 보낸다.  
 - `killall` - 프로세스명으로 프로세스를 종료시킨다.  
 - `shutdown` - 시스템을 종료하거나 재시작한다.  

## 프로세스는 어떻게 동작하는가?  

- 시스템이 구동될 때, 커널은 몇몇 프로세스를 초기화하고 init이라는 프로그램을 실행  
- init은 차례차례 모든 시스템 서비스를 시작하기 위해 **init 스크립트**라고 불리는 쉘 스크립트(/etc에 위치)들을 실행  
 - 많은 서비스들은 데몬 프로그램으로 구현  
    - **데몬 프로그램**은 아무런 사용자 인터페이스 없이 백그라운드 상태로 실행. 때문에 로그인하지 않은 상태에서도 시스템은 최소한의 필요 작업들을 수행  
- 프로그램은 또 다른 프로그램을 실행 가능. 이를 프로세스 체계에서는 **부모 프로세스**가 **자식 프로세스**를 생성한다고 표현  
- 커널은 프로세스를 구조화된 형태로 유지하기 위해 각 프로세스의 정보를 가짐.  
 - 각각의 프로세스는 **프로세스 ID(Process ID, PID)**라고 불리는 번호를 할당 받는다.  
 - PID는 오름차순으로 할당, PID 1번은 항상 init이 된다.  
 - 커널은 실행 재개를 대기중인 프로세스도 포함하여 각 프로세스에 할당된 메모리 공간을 유지  
 - 프로세스도 파일처럼 소유자와 사용자 ID, 유효 사용자 ID등을 가지고 있다.  

### ps 명령어로 프로세스 보기  

```
[me@linuxbox ~]$ ps
  PID TTY          TIME CMD
17273 pts/2    00:00:00 bash
18334 pts/2    00:00:00 ps
```
- 프로세스 17273과 18334는 각각 bash와 ps를 나타냄  
- ps는 현재 터미널 세션과 관련된 프로세스만을 보여줌.  
- TTY는 teletype의 약자로 프로세스용 **제어 터미널**을 나타냄.  
- TIME 필드는 프로세스의 CPU 사용 시간  
- x 옵션을 추가하면 시스템 전체의 상황을 살펴볼 수 있음.  
 - TTY 항목의 ? 표시는 아무런 제어 터미널이 없다는 것.  
 - STAT은 state(상태)의 약자로 프로세스의 현재 상태를 나타냄  
- 프로세스의 상태  

 | 상태 값 | 의미 |  
 | :---: | --- |  
 | R | 실행 상태. 프로세스는 실행 중이거나 실행 대기 중 |  
 | S | 수면 상태. 프로세스는 실행 중이 아니고, 키 입력이나 네트워크 패킷과 같은 이벤트를 기다리는 중 | 
 | D | 인터럽트 불가능한 수면 상태. 프로세스는 I/O를 기다리는 중(디스크 입출력 등) |  
 | T | 종료 상태. 프로세스는 종료 요청을 받았거나 종료된 상태 |  
 | Z | 현존하지 않거나 "좀비" 프로세스. 부모 프로세스에 의해 정리되지 않은 종료된 자식 프로세스 |  
 | < | 높은 우선순위 프로세스. 특정 프로세스에 CPU 시간을 더 주는 것인데 niceness라고 한다. |  
 | N | 낮은 우선순위 프로세스. 더 높은 우선순위 프로세스가 사용한 뒤 프로세서 시간을 얻을 수 있다. |  

- aux 옵션은 더 많은 정보를 준다.  
 - 모든 사용자에 속한 프로세스들을 보여줌. 대시 기호 없이 BSD 스타일로 명령을 실행 
 - BSD 스타일의 ps 헤더들 

   | 헤더 | 의미 | 
   | --- | --- | 
   | USER | 사용자 ID, 프로세스 소유자 |  
   | %CPU | CPU 사용량(%) |  
   | %MEM | 메모리 사용량(%) | 
   | VSZ | 가상 메모리 크기 |  
   | RSS | 사용 메모리 크기. 프로세스가 사용중인 물리적 메모리(RAM)량(KB) | 
   | START | 프로세스가 시작된 시각. 24시간이 넘으면 날짜를 사용 |  

### top 명령어로 프로세스 변화 보기  
- ps는명령어가 실행된 순간의 상태에만 제공하기 대문에 동적으로 보려면 top을 사용   
- top 프로그램은 프로세스 활동순으로 나열된 시스템 프로세스들을 지속적으로 갱신해 보여준다(기본적으로 3초).  
- 최상위에 시스템 요약과 그 아래 CPU 활동순으로 정렬된 프로세스 테이블이 표시   
```
top - 10:32:11 up 38 min,  1 user,  load average: 0.00, 0.01, 0.06
Tasks: 186 total,   1 running, 185 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.7 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  4046148 total,  2124464 free,   602588 used,  1319096 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3169988 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 1731 dev       20   0  543472  39424  32696 S   0.3  1.0   0:00.13 hud-service 
17284 dev       20   0   50148   4076   3512 R   0.3  0.1   0:00.08 top         
    1 root      20   0  185584   6244   4016 S   0.0  0.2   0:01.23 systemd     
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd    
    3 root      20   0       0      0      0 S   0.0  0.0   0:00.11 ksoftirqd/0 
    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:+ 
    6 root      20   0       0      0      0 S   0.0  0.0   0:00.12 kworker/u8+ 
    7 root      20   0       0      0      0 S   0.0  0.0   0:00.39 rcu_sched   
    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh      
    9 root      rt   0       0      0      0 S   0.0  0.0   0:00.03 migration/0 
   10 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 watchdog/0  
   11 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 watchdog/1  
   12 root      rt   0       0      0      0 S   0.0  0.0   0:00.06 migration/1 
   13 root      20   0       0      0      0 S   0.0  0.0   0:00.12 ksoftirqd/1 
   14 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kworker/1:0 
   15 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/1:+ 
   16 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kdevtmpfs  
```

- 키보드 명령어 h는 프로그램 도움말 화면을 보여주고, q는 top 프로그램을 종료한다.   

## 프로세스 제어  

```
[me@linuxbox ~]$ xlogo
```
- 위 명령어를 입력하면 xlogo 프로그램이 실행되고 쉘 프롬프트로 돌아가지 않는다. 이는 쉘이 프로그램 종료를 기다리고 있기 때문  
- xlogo 창을 닫으면 비로소 프롬프트로 돌아온다. 다른 프로그램들도 xlogo와 다를 바 없다.  

### 프로세스 인터럽트하기  

- 터미널에서 xlogo를 입력해 프로그램을 실행하고 다시 터미널 창으로 돌아와 <kbd>CTRL</kbd>-<kbd>C</kbd>를 누르면 프로그램이 중단된다.  
- 많은(전부는 아닌) 커맨드라인 프로그램들은 이 입력으로 프로그램 중단이 가능  

### 프로세스를 백그라운드로 전환  

- xlogo 프로그램의 종료 없이 쉘 프롬프트로 돌아가기를 원한다면 프로그램을 **백그라운드**로 전환하는 것이다.  
- 터미널이 **포그라운드**(쉘 프롬프트처럼 화면에 표시되는 것)와 백그라운드(화면 뒤로 숨겨진 것)를 가진다고 생각해보면, & 기호를 사용하면 프로그램을 실행 즉시 백그라운드로 이동한다.  

```
[me@linuxbox ~]$ xlogo &
[1] 17564
[me@linuxbox ~]$
```  
- 입력 후 xlogo 창이 나타나고, 쉘 프롬프트로 돌아온다. 숫자를 출력하는데 이 메시지는 **작업 제어(job control)**라고 부르는 쉘의 기능  
- 쉘은 이 메시지로 PID가 17564인 1번([1]) 작업이 시작되었다는 것을 알림. ps를 실행하면 이 프로세스를 볼 수 있다.  
- 쉘의 작업 제어 시스템은 터미널에 실행 중인 작업을 나열해줌. jobs 명령어를 사용하면 된다.  
```
[me@linuxbox ~]$ jobs
[1]+  Running                 xlogo &
```  
- 작업 번호가 1이고, 실행 중이며, 명령어는 xlogo & 이라는 뜻  

### 프로세스를 포그라운드로 전환  
- 백그라운드에 있는 프로세스는 <kbd>CTRL</kbd>-<kbd>C</kbd> 를 통한 프로세스 중단을 포함해 어떤 키보드 입력도 영향을 받지 않는다.  
- 프로세스를 포그라운드로 전환하려면 fg 명령어를 사용  
 - fg 명령어는 퍼센트 기호(%)와 작업 번호(jobspec)를 사용. 만약 하나의 백그라운드 작업만을 가지고 있다면 jobspec은 생략 가능  
 ```
 dev@ubuntu-machine:~$ jobs
 [1]+  Running                 xlogo &
 dev@ubuntu-machine:~$ fg %1
 xlogo
 ``` 
 - 여기서 xlogo를 종료하려면 <kbd>CTRL</kbd>-<kbd>C</kbd>를 누르면 된다.  

### 프로세스 정지(일시 정지)  

- 종료하지 않고 멈추고 싶을 때, 포그라운드 프로세스를 백그라운드로 이동하기 위해..
- <kbd>CTRL</kbd>-<kbd>Z</kbd>를 누르면 된다.

## 시그널  

- kill 명령어는 프로세스를 종료하기 위해 사용. 비정상적으로 동작하거나 종료를 거부하는 프로그램의 실행이 끝나게 해준다.  
- 정확히 종료하지는 않는다. 오히려 프로세스에 시그널을 보낸다는 표현이 옳다.  
 - 시그널은 운영체제가 프로그램들과 통신하기 위한 여러 방법 중 하나.  
 - <kbd>CTRL</kbd>-<kbd>C</kbd>나 <kbd>CTRL</kbd>-<kbd>Z</kbd>를 누르는 것도 시그널을 보낸 것이다. 
 - 프로그램들은 결국 시그널을 귀 길울이고("listen") 있다가 받은 시그널에 따라 행동하게 될 것이다.  

### kill로 시그널 보내기  

```
kill [-signal] PID...
```
- 커맨드라인에 지정된 시그널이 없다면, 기본적으로 TERM(종료) 시그널을 보낸다. kill 명령어는 다음 표에 있는 시그널을 주로 사용  

 | 번호 | 이름 | 의미 |  
 | --- | --- | --- |  
 | 1 | HUP | Hang up. "연결이 끊어진" 프로그램을 가리킨다. 포그라운드 프로그램은 이 시그널을 받으면 종료. |
 | 2 | INT | Interrupt. 터미널에서 <kbd>CTRL</kbd>-<kbd>C</kbd> 키를 보낸 것과 동일 | 
 | 9 | KILL | Kill. 이 시그널은 실제로 해당 프로그램에 보내지지 않고, 커널이 즉시 프로세스를 종료. 최후의 수단으로 사용  | 
 | 15 | TERM | Terminate. kill 명령어가 보내는 기본 신호 |  
 | 18 | CONT | Continue, STOP 시그널로 정지된 프로세스를 복원 |  
 | 19 | STOP | Stop. 프로세스를 종료 없이 일시 정지시킨다. KILL 시그널 처럼 해당 프로세스에 직접 x |  

- 그 외 주요 시그널  
 
 | 번호 | 이름 | 의미 |  
 | --- | --- | --- |
 | 3 | QUIT | Quit | 
 | 11 | SEGV | Segmentation violation. 프로그램이 잘못된 메모리 사용이 이뤄질 때 보내짐. 허용하지 않은 영역에 쓰기 사용 시 |  
 | 20 | TSTP | Terminal Stop. <kbd>CTRL</kbd>-<kbd>Z</kbd> 누를 시  |  
 | 28 | WINCH | Window change. 윈도우 크기가 변경된 경우에 시스템에 의해 보내짐 |  

### killall로 다수의 프로세스에 시그널 보내기  

```
killall [-u user] [-signal] name ... 
```

- xlogo 프로그램을 두 번 시작하면 종료하는 것은 다음과 같다.  
```
[me@linuxbox ~]$ xlogo &
[1] 17650
[me@linuxbox ~]$ xlogo &
[2] 17652
[me@linuxbox ~]$ killall xlogo
[2]+  Terminated              xlogo
[1]+  Terminated              logo
```
- kill 명령어와 마찬가지로 사용자가 소유하지 않은 프로세스들에 시그널을 보낼 때는 반드시 슈퍼유저야 함을 명심  

## 기타 프로세스 관련 명령어들  

| 명령어 | 설명 | 
| --- | --- |
| pstree | 프로세스 간의 부모/자식 관계를 보여주는 트리 형태로 정렬해 프로세스 목록을 출력 |  
| vmstat | 메모리, 스왑, 디스크 I/O를 포함한 시스템 자원 사용 현황을 출력 지속적으로 갱신하려면 지연 값과 함께 사용(예, vmstat 5). <kbd>CTRL</kbd>-<kbd>C</kbd>로 종료 | 
| xload | 시간에 따라 시스템 부하를 그래프로 보여주는 그래픽 프로그램 |  
| tload | xload와 유사하지만 터미널에서 그래프를 보여준다. <kbd>CTRL</kbd>-<kbd>C</kbd>로 출력 종료 |