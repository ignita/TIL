# 알고리즘 
- 문제 해결을 위한 계산의 실행 순서 
 - 요리로 치면 레시피 

## 데이터 구조 


### 리스트 
- 각 데이터에 포인터가 있고, 그 포인터가 다음 데이터의 메모리 위치를 가리킨다.  
- 리스트에서는 데이터가 메모리상의 연속된 위치에 저장되지 않아도 되고, **일반적으로는 떨어진 영역에 흩어져서 저장** 
 - 흩어져 있으니 포인터를 처음부터 순서대로 따라가야지 원하는 데이터에 접근이 가능.  
 - 순차 접근 또는 시퀀셜 액세스(sequential access) 
- 추가나 삭제시에는 포인터를 바꾸기만 하면 되기 때문에 간단하지만 데이터에 접근하는 것은 시간이 오래걸린다. 
- 데이터 수가 n이면, 리스트 앞에서부터 데이터에 접근하기 때문에 접근하고픈 데이터가 뒤쪽인 경우에는 O(n)의 계산시간이 걸림. 
- 데이터 추가는 두 개의 포인터만 변경하면 되기에 n에 관계없는 상수 시간 O(1).  
- 마지막 데이터의 포인터가 선두를 가리키게 되면 원형 리스트(순환 리스트) - 선두, 후미 개념 x 
- 앞뒤 데이터를 가리키도록하는 '양방향 리스트'도 존재 - 삭제시 바꿔야할 포인터의 수가 많아진다. 


### 배열 
- 데이터를 1열로 나열한 것. 
- 데이터 접근은 쉽지만, 추가 삭제에 시간이 많이 걸린다. 
- 접근에는 O(1)의 계산 시간, 데이터 추가, 삭제는 O(n)의 시간 


### 스택 
- Last In First Out - 후입선출 구조 
- 데이터의 추가나 삭제가 단방향으로 흐름. 
- 접근도 가장 위에 있는 데이터만 가능. 
- 데이터를 꺼내는 것 - `POP` 
- 데이터를 넣는 것 - `PUSH`

### 큐 
- First In First Out - 선입선출 구조 
- 큐는 추가하는 쪽과 삭제하는 쪽이 반대 
- 데이터를 꺼내는 것 - `DEQUEUE`
- 데이터를 넣는 것 - `ENQUEUE` 
- 오래된 데이터부터 순서대로 처리하는 것은 매우 자연스러운 방식이어서 큐는 폭 넓게 활용 된다. 

### 해시 테이블 
- 해시 함수를 이용해 데이터 검색을 효율적으로 하기 위해 사용되는 구조  
- 해시 테이블은 키(key)와 값(value)이 한 쌍을 이루는 데이터를 저장. 
- 데이터 저장 시 배열을 사용하는 경우 
 - 해시 함수를 이용해 해당 키의 해시값을 계산
 - 배열의 길이로 해시값을 나누어 나머지를 구한다. (mod 연산) 
 - mod 연산 결과와 같은 배열 인덱스에 해당 데이터를 저장 
 - 연산 결과가 같은 데이터는 이미 데이터가 있어 충돌이 일어나는데, 리스트 구조로 연결한다.  
- 데이터 검색 
 - 찾고자 하는 데이터의 해시값을 구한 뒤 배열의 크기로 mod 연산 수행 
 - mod 연산 값이 배열의 인덱스
 - 해당 데이터가 없으면 그 데이터를 선두로 해서 만들어진 리스트를 탐색 
- **데이터 충돌 시 리스트를 이용해 연결하는 것을 연쇄법 또는 체이닝(chaining) 이라고 한다.**
- 연쇄법 말고도 개방 주소법(open addressing)이라는 것도 있음  
 - 충돌이 발생한 경우 다음 후보가 될 주소(배열상의 위치)를 구해 거기에 저장  
 - 해당 주소에도 데이터가 있다면 다음 후보 주소를 구해 비어 있는 곳을 찾을 때까지 다음 후보 주소를 구한다. 
 - 다음 주소를 구하는 방법에는 해시 함수를 여러 개 사용하거나 선형탐사 등을 사용 

### 힙 
- 트리 구조, 각 정점을 노드(node)라고 부른다. 
- 데이터 저장 위치를 정하기 위해 자식 노드의 숫자는 반드시 부모의 숫자보다 커야 한다. 
- 가장 맨위에 가장 작은 숫자가 있음 
- 데이터 추가 시에는 가장 아래층 왼쪽 노드부터 값을 채운다. 

### 이진 탐색 트리 
- 트리 구조 
- 모든 노드는 왼쪽 가지에 포함되는 어떤 숫자보다 큰 숫자 
- 모든 노드는 오른쪽 가지에 포함되는 어떤 숫자보다 작은 숫자 
- 위 두 조건으로 인해 최소 노드는 최상단에 있는 노드에서 왼쪽 가지만 계속 따라가면 나오는 가장 끝 노드 
- 반대로, 최대 노드는 최상단 노드로부터 오른쪽 가지만 따라가면 나오는 가장 끝 노드 
- 추가 시에는 최상단 노드부터 탐색해 현재 노드 값과 비교해 작으면 왼쪽, 크면 오른쪽로 진행
- 삭제 시에는 왼쪽 가지에서 최대 노드를 찾거나 오른쪽 가지의 최소 노드를 찾아 삭제한 노드의 위치로 이동 